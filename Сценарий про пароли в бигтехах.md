Здоров, котаны, пару лет уж я наблюдаю, как российские бигтехи постепенно хрюкнулись и стали ограничивать возможные символы в паролях.

![[sber.jpg|600]]

Иии, если раньше я думал, что это какие-то отдельные частные случаи, то сейчас мне уже так не кажется. Это такая феерия идиотизма с одной стороны и такой показатель беспросветного непрофессионализма с другой, что это важно зафиксировать.

О чём речь. Речь о том, что вход в большинство сервисов осуществляется по паролю и чаще всего пароль мы задаём сами. И сервис иногда имеет *требования* к этому паролю. Например, большинство сервисов не пропустит слишком короткий пароль, состоящий из, например, трёх символов, потому что такой пароль можно будет быстро подобрать простым перебором. Пароль из трех символов — это попросту небезопасно, и ограничение минимальной длины пароля объективно разумно.

Сервисы же обычно заставляют нас ставить **безопасные** пароли — длинные, состоящая из букв, цифр и спецсимволов.  Чем длиннее пароль и чем большее количество символов используется для его составления, тем большее количество *вариантов* таких паролей существует, и тем сложнее, соответственно, такой пароль подобрать.

Но что же мы видим? Мы видим, что Сбербанк, например, позволяет использовать только разрешённые символы. Например, символ процента и амперсанда использовать в пароле можно, а вот символ кавычки — нельзя. Почему? А вот потому! Вот в Сбербанке изобрели собственную криптографию, в соответствии с которой чтобы пароль был более безопасным, надо... чтобы он был менее безопасным. Вот такая вот криптография! Специальная такая! Инновационная нанотехнологичная криптография!

Аналогично поступает Яндекс для бизнеса — при добавлении сотрудника в Яндекс 360 нельзя вот так взять и использовать произвольный спецсимвол. Альфабанк тоже занимается изобретением собственной криптографии. Туда же Рамблер, cloud.ru. Да что там говорить, люди в себя поверили уже даже в госушных сервисах и такие кренделя выписывают, шо мама не горюй! Личный кабинет индивидуального предпринимателя, пожалуйста, символ решётки использовать можно, а вопросительный знак — нельзя. Ну а чё там вопрошать в пароле? Правильно? Правильно. Незачем.

Даже госуслули не позволяют ввести любой спецсимвол и ограничивают набор спецсимволов, которые можно использовать в пароле.

Причём вот в личном кабинете ИП, скажем, звёздочку использовать в пароле можно, а в госуслугах нельзя. А кавычки в госуслугах можно, а больше нигде — нельзя! А вот скобки в альфа-банке нельзя, а в сбербанке и яндексе можно. Мамкины криптографы пока не договорились, что можно, а что нельзя, что безопасно, а что нет. Тут, вероятно, просто дело такое, что во всех этих организациях изобретается своя собственная, православная криптография, и они, эти криптографии, не всегда пересекаются.

Ну, ладненько. Почему это бред?

Ну, во-первых, есть такая штука как комбинаторика. Проходят её в 9м классе школы. То есть, если люди ушли после девятого класса в техникум, а оттуда сразу пошли работать в Сбербанк и Яндекс и Госуслуги, то в целом про комбинаторику они всё равно знать должны.

Так вот в комбинаторике есть такая штука как размещения с повторениями. Она позволяет считать количество вариантов паролей длины `LENGTH`, составленного из символов количеством `SYMBOLS`. И число вариантов паролей составляет `SYMBOLS ^ LENGTH`.

Вот, например, сколько разных паролей длиной 3 символа может быть составлено из английского алфавита? Как мы знаем, в английском алфавите 26 символов. Поэтому количество версий пароля составляет ( 26^3 ), 17576 паролей. Это не очень много, можно подобрать такой пароль.

А если добавить ещё возможность использовать большие символы алфавита? Будет уже 52 символа в степени 3, 140608. Это в 8 раз больше, чем пароли из только маленьких символов.

Если добавить сюда цифры, получится 62 в третьей степени, то есть 238328.

Если добавить сюда 33 спецсимвола, которые можно легко набрать на клавиатуре, то получится уже 95 в третьей степени, 857375. Это в 48 раз больше, чем просто маленькие символы английского алфавита.

То есть мы понимаем, что чем больше разных символов мы можем использовать в пароле, тем большее количество паролей одной и той же длины мы можем создать. Тем безопаснее соответственно будет пароль, тем дольше, например, его надо будет подбирать.

Давайте зафиксируем эту простую мысль, доступную девятикласснику. Если в пароле можно использовать все 33 спецсимвола, он будет надёжнее, безопаснее, чем если в пароле можно использовать только 12 спецсимволов, как в большинстве обсуждаемых сервисов. Это комбинаторика, она так работает, есть формула, можно построить график. Это суровый математический аппарат, повторюсь, девятого класса. Надёжность пароля *снижается* при сокращении количества возможных к использованию в пароле символов. Запрет на использовании в пароле восклицательного знака *снижает* его надёжность.

Яндекс, Сбер, Альфабанк, Рамблер, госуслуги и тд — *снижают* безопасность паролей, не позволяя использовать любые символы.

Мы сейчас даже не говорим об использовании произвольных UTF8 символов, например, кириллицы или emoji (==покажи пример пароля с emoji==). Это уж ладно, это уж куда нам.

Это первая мысль. Запрет на использование в пароле какого-то спецсимвола — снижает его безопасность.

Вторая мысль. Давайте порассуждаем, откуда тут могут расти ноги, что в пароле нельзя использовать какой-то символ.

Одни активно пишут мне в комментах — ну так это жо защита от SQL-инъекции! Ну ты шо, Алексей, ну такие-то уж вещи знать надо, НУ ШО ТЫ ВОТ НАМ РАССКАЗЫВАЕШЬ, ВЫЛЕЗ, КОВЫЧКИ ЕМУ В ПОРОЛЕ ПОДОВАЙ!

И если такое говорит бэкенд-разработчик, то братан, извини, тебя допускать до бэкенд-разработки-то не надо, это нахрен чревато! Чревато! О чём речь. Речь о том, что вот мы используем PostgreSQL и например Python — это всё актуально и для других языков и СУБД, просто для примера ([github](https://github.com/alexey-goloburdin/innovative-bigtech-cryptography-demo/tree/password_as_plain_text_and_sql_injection)):

```python
import os

import asyncpg
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

load_dotenv()

app = FastAPI()

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL must be set in .env")

USER_ID = 1


class ChangePasswordRequest(BaseModel):
    password: str


class CheckPasswordRequest(BaseModel):
    password: str


class CheckPasswordResponse(BaseModel):
    valid: bool


async def get_connection():
    return await asyncpg.connect(DATABASE_URL)


@app.post("/password", status_code=204)
async def change_password(payload: ChangePasswordRequest) -> None:
    """
    Change password for the user with id=1.
    """
    conn = await get_connection()

    try:
        result = await conn.execute(
            f"UPDATE users SET password = '{payload.password}' "
            f"WHERE id = {USER_ID}"
        )

        if result == "UPDATE 0":
            raise HTTPException(status_code=404, detail="User not found")

    finally:
        await conn.close()


@app.post("/password/check", response_model=CheckPasswordResponse)
async def check_password(
    payload: CheckPasswordRequest,
) -> CheckPasswordResponse:
    """
    Check given password for the user with id=1.
    """
    conn = await get_connection()
    try:
        row = await conn.fetchrow(
            f"SELECT password FROM users WHERE id = {USER_ID}"
        )
    finally:
        await conn.close()

    if row is None:
        return CheckPasswordResponse(valid=False)

    stored_password = row["password"]
    return CheckPasswordResponse(valid=(stored_password == payload.password))
```

Тут есть 2 сервиса — один устанавливает новый пароль пользователю с заданным идентификатором, а второй сервис проверяет переданный пароль, что он соответствует хранящему в базе данных. Это такая простенькая демка с одним пользователем для демонстрации того, как *в принципе* можно работать с паролем в системе.

```shell
# Меняем пароль пользователю
curl http://localhost:8000/password \
  -H "Content-Type: application/json" \
  -d '{"password": "new_pass"}' \
  -v

# Проверяем, что передан верный пароль пользователя
curl http://localhost:8000/password/check \
  -H "Content-Type: application/json" \
  -d '{"password": "new_pass"}'
```

Код хранится в БД сейчас просто в открытом виде. Смотрим код смены пароля:

```python
        result = await conn.execute(
            f"UPDATE users SET password = '{payload.password}' "
            f"WHERE id = {USER_ID}"
        )
```

Тут есть SQL-инъекция, то есть злоумышленник может передать параметр нового пароля таким, что выполнится произвольный SQL-код. Например, пользователь передаёт вот такой пароль:

```
'; drop table users; --
```

команда в CURL выглядит так:

```shell
curl http://localhost:8000/password \
  -H "Content-Type: application/json" \
  -d '{"password": "'\''; drop table users; --"}' \
  -v
```

И на самом деле мы сейчас удалили таблицу `users`. Давайте посмотрим в `psql`, чтобы в этом убедиться.

Почему так произошло? Потому что в БД ушёл такой запрос:

```sql
UPDATE users SET password = ''; drop table users; --' WHERE id = {USER_ID}
```

то есть мы внедрили злонамеренный SQL-запрос и он просто выполнился. Оставшаяся часть запроса после двух символов дефиса не выполнилась, потому что часть после двух дефисов считается комментарием в SQL-запросе и попросту игнорируется.

Как этого избежать? Сейчас уязвимость стала возможной, потому что мы явно разрешаем в пароль вставлять символ кавычки. Давайте просто запретим это делать! Вот просто запретим использовать символ кавычки в пароле и всё:

```python
@app.post("/password", status_code=204)
async def change_password(payload: ChangePasswordRequest) -> None:
    """
    Change password for the user with id=1.
    """
    if "'" in payload.password:
        raise HTTPException(
            status_code=400,
            detail="Password cannot contain a single quote '.",
        )
    conn = await get_connection()

    try:
        result = await conn.execute(
            f"UPDATE users SET password = '{payload.password}' "
            f"WHERE id = {USER_ID}"
        )

        if result == "UPDATE 0":
            raise HTTPException(status_code=404, detail="User not found")

    finally:
        await conn.close()

@app.post("/password/check", response_model=CheckPasswordResponse)
async def check_password(
    payload: CheckPasswordRequest,
) -> CheckPasswordResponse:
    """
    Check given password for the user with id=1.
    """
    if "'" in str(USER_ID):
        raise HTTPException(
            status_code=500,
            detail="Incorrect user_id.",
        )
    ...
```

[github](https://github.com/alexey-goloburdin/innovative-bigtech-cryptography-demo/tree/password_as_plain_text_and_quote_filter)

Теперь попытка провести такую атаку на SQL-инъекцию не проходит. Ура-ура! Мы всё побороли! Или не всё? А точно всё побороли?

А вот ещё вопрос — а как насчёт отправки, например, произвольных сообщений, в которых может быть любой символ? Ведь там кавычку могут ведь отправить. Вот вы комментарии под видео пишете — там ведь кавычку можно отправить, и любой вообще символ можно отправить? Но при этом уязвимости нет. Как тогда это сделано?

А сделано это просто *по-уму*. По уму не надо фильтровать ввод, который приходит от пользователя, на предмет наличия в нём кавычек или любых других потенциально вредных символов. Надо просто использовать параметризованные запросы, вот так:

```python
@app.post("/password", status_code=204)
async def change_password(payload: ChangePasswordRequest) -> None:
    """
    Change password for the user with id=1.
    """
    conn = await get_connection()

    try:
        result = await conn.execute(
            "UPDATE users SET password = $1 WHERE id = $2",
            payload.password,
            USER_ID
        )

        if result == "UPDATE 0":
            raise HTTPException(status_code=404, detail="User not found")

    finally:
        await conn.close()


@app.post("/password/check", response_model=CheckPasswordResponse)
async def check_password(
    payload: CheckPasswordRequest,
) -> CheckPasswordResponse:
    """
    Check given password for the user with id=1.
    """
    if "'" in str(USER_ID):
        raise HTTPException(
            status_code=500,
            detail="Incorrect user_id.",
        )
    conn = await get_connection()
    try:
        row = await conn.fetchrow(
            "SELECT password FROM users WHERE id = $1",
            USER_ID
        )
    finally:
        await conn.close()

    if row is None:
        return CheckPasswordResponse(valid=False)

    stored_password = row["password"]
    return CheckPasswordResponse(valid=(stored_password == payload.password))
```

[github](https://github.com/alexey-goloburdin/innovative-bigtech-cryptography-demo/tree/password_as_plain_text_and_no_sql_injection)

Тогда в PostgreSQL отдельно передаётся запрос и отдельно параметры запроса, и параметры запроса никогда не рассматриваются как исполнимый код. И вот это 100% надёжная, правильная, корректная защита от SQL-инъекции.

Ещё раз, правильная, 100% надёжная защита от SQL-инъекции это использование параметризованных запросов, всё. Никакой фильтр пришедших от пользователя данных не является надёжной защитой от SQL-инъекции.

Есть OWASP (==покажи OWASP: Open Worldwide Application Security Project==). OWASP — это один из самых авторитетных источников в области практической информационной безопасности приложений. Он расшифровывается как Open Worldwide Application Security Project. И там есть [документ](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html) (==покажи QR на него==), «SQL Injection Prevention Cheat Sheet», в нём описаны способы предотвращения SQL-инъекций, их четыре (==покажи скриншот==):

- **Option 1: Use of Prepared Statements (with Parameterized Queries)**
- **Option 2: Use of Properly Constructed Stored Procedures**
- **Option 3: Allow-list Input Validation**
- **Option 4: STRONGLY DISCOURAGED: Escaping All User Supplied Input**

На первом месте — те самые параметризованные запросы. На втором хранимые процедуры, если вы не знаете, что это, то вам оно и не нужно, на третьем валидация входных данных через белый список, это мало где применимо, и на последнем месте, отмечено как *крайне не рекомендуемый* способ — фильтрация входных данных.

Переведу часть документа как раз про фильтрацию входных данных:

```
При таком подходе разработчик будет очищать все вводимые пользователем данные перед их помещением в запрос. Этот подход очень зависит от конкретной базы данных. По сравнению с другими методами защиты эта методология является неэффективной, и мы НЕ МОЖЕМ гарантировать, что этот вариант предотвратит все SQL-инъекции во всех ситуациях.

Если приложение создается с нуля или требует низкой толерантности к рискам, его следует создавать или переписывать с использованием параметризованных запросов, хранимых процедур или какого-либо объектно-реляционного маппера (ORM), который создает запросы за вас.
```

Поэтому никакой фильтрации символов и только параметризованные запросы. Ещё раз, фильтрация какого бы то ни было спец символа это НЕ защита от SQL-инъекции, а если кто-то в яндексе, сбере, альфабанке, рамблере или госуслугах воспринимает эти фильтры как защиту от SQL-инъекций, тоооо он просто некомпетентен и дожидается ссаных тряпок, которыми его скоро выгонят на мороз, чтобы ходить и ныть о несправедливости бытия.

Более того. Пароли в открытом виде хранить нельзя. Ну нельзя! Ну нельзяяяяя!

Потому что любая утечка базы данных сразу компрометирует все пароли, потому что они в открытом виде там хранятся. Все аккаунты сразу взломаны. А многие люди к тому же используют одни и те же пароли в нескольких сервисах, и тогда аккаунты во всех этих сервисах тоже под угрозой.

А знаете, кстати, что делать, чтобы у пользователей во всех сервисах были разные, причём надёжные, безопасные пароли? Надо, чтобы просто пользователи использовали менеджеры паролей, которые бы хранили пароли, генерировали пароли, напоминали о необходимости их поменять и так далее. И штука в том, что все эти генераторы паролей генерят пароли со всем набором спецсимволов, и эти сгенерированные пароли ни черта не подходят в Сбер, яндекс, альфу и прочие сервисы, потому что там мамкины криптографы изобретают инновационную криптографию, по которой, видите ли, кавычки в паролях использовать нельзя!

Понимаете? Эти сервисы буквально говорят вам — создай надёжный пароль, но не слишком надёжный, вот спецсимволы используй, но не все, вот кавычку или вопросительный знак не используй. Почему? Ну вот потому что. Вот потому что! И всё! И вот тот пароль, что тебе твой менеджер паролей сгенерировал, уже невалиден для сервиса, потому что его надо сделать *менее* безопасным, *убрав* из него часть спецсимволов. Ну не бред ли? Аааа вот так вот!

Так или иначе, повторюсь, в БД пароли не хранят в открытом виде, чтобы никто не знал эти пароли, в том числе администраторы БД, чтобы утечка БД не приводила к компрометации всех аккаунтов и тд. Вообще говоря, хранение паролей в открытом виде это нарушение стандартов и законодательных актов, например, нарушение GDPR (==покажи GDPR==), штраф до 20 млн евро, нарушение PCI DSS (==покажи PCI DSS==) и тд. Любой аудит информационной безопасности такое не пропустит. Ну, я не знаю, может Сберу или Яндексу можно чёто такое, чего остальным нельзя, это уж дело такое.

Как правильно хранить пароли? Опять обращаемся к OWASP (==покажи QR на https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html ==), статья «Password Storage Cheat Sheet». Читаем:

```
В этом справочнике приведены рекомендации по правильным методам хранения паролей для аутентификации. При хранении паролей они должны быть защищены от злоумышленников даже в случае взлома приложения или базы данных. К счастью, большинство современных языков и фреймворков предоставляют встроенные функции, помогающие безопасно хранить пароли.

Однако, как только злоумышленник получит хэши сохраненных паролей, он всегда сможет провести брутфорс-атаку на хэши в автономном режиме. Защитники могут замедлить автономные атаки, выбирая алгоритмы хеширования, которые требуют как можно больше ресурсов.

Подводя итог наших рекомендаций:
- используйте Argon2id с минимальной конфигурацией 19 МБ памяти, количеством итераций 2 и степенью параллелизма 1.
```

Что такое Argon2id? Это алгоритм хеширования. Пароли в БД хранят в виде хешей. В момент задания пароля от него вычисляется хэш, и этот хэш сохраняется в базу данных. Восстановить пароль по хэшу невозможно, это необратимый процесс. Когда пользователь проходит аутентификацию и вводит пароль, от него снова вычисляется хэш и сравнивается с тем хэшем, который хранится в базе данных. Если хэши совпадают, значит, пользователь ввел правильный пароль.

При этом в такой схеме никто из разработчиков и администраторов базы данных не видит реальные пароли пользователей. При утечке базы данных там просто лежат какие-то непонятные хэши, и всё хорошо.

```shell
uv add argon2-cffi
```

код:

```python
import os

import asyncpg
from argon2 import PasswordHasher, exceptions
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

load_dotenv()

app = FastAPI()

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL must be set in .env")

USER_ID = 1

PASSWORD_HASHER = PasswordHasher(
    time_cost=2, memory_cost=19 * 1024, parallelism=1
)


def hash_password(plain_password: str) -> str:
    """
    Принимает обычный пароль и возвращает строку-хеш Argon2id.

    Эту строку и нужно сохранять в БД.
    """
    return PASSWORD_HASHER.hash(plain_password)


def verify_password(plain_password: str, stored_hash: str) -> bool:
    """
    Возвращает True, если введённый пароль соответствует сохранённому хешу,
    иначе False.
    """
    try:
        return PASSWORD_HASHER.verify(stored_hash, plain_password)
    except exceptions.VerifyMismatchError:
        # Пароль не подходит
        return False
    except exceptions.VerificationError:
        # Некорректный формат хеша или другая ошибка верификации
        return False


class ChangePasswordRequest(BaseModel):
    password: str


class CheckPasswordRequest(BaseModel):
    password: str


class CheckPasswordResponse(BaseModel):
    valid: bool


async def get_connection():
    return await asyncpg.connect(DATABASE_URL)


@app.post("/password", status_code=204)
async def change_password(payload: ChangePasswordRequest) -> None:
    """
    Change password for the user with id=1.
    """
    if "'" in payload.password:
        raise HTTPException(
            status_code=400,
            detail="Password cannot contain a single quote '.",
        )
    conn = await get_connection()

    try:
        result = await conn.execute(
            "UPDATE users SET password = $1 WHERE id = $2",
            hash_password(payload.password),
            USER_ID,
        )

        if result == "UPDATE 0":
            raise HTTPException(status_code=404, detail="User not found")

    finally:
        await conn.close()


@app.post("/password/check", response_model=CheckPasswordResponse)
async def check_password(
    payload: CheckPasswordRequest,
) -> CheckPasswordResponse:
    """
    Check given password for the user with id=1.
    """
    if "'" in str(USER_ID):
        raise HTTPException(
            status_code=500,
            detail="Incorrect user_id.",
        )
    conn = await get_connection()
    try:
        row = await conn.fetchrow(
            "SELECT password FROM users WHERE id = $1", USER_ID
        )
    finally:
        await conn.close()

    if row is None:
        return CheckPasswordResponse(valid=False)

    stored_password_hash = row["password"]
    return CheckPasswordResponse(
        valid=(verify_password(payload.password, stored_password_hash))
    )
```

[github](https://github.com/alexey-goloburdin/innovative-bigtech-cryptography-demo/tree/password_as_hash)

обновляем пароль, проверяем его

хеш, хранимый в БД:

```
$argon2id$v=19$m=19456,t=2,p=1$226kFIQ3zB9Ece1v6Osfpg$qPlP/LiPKNiKhaP28v6vS8ud7cWnqGWJQ0IQykPHGms
```

И — как видите, тут нет никаких кавычек, вопросительных и восклицательных знаков. Это хеш. Давайте поменяет пароль на что-то прям злое, со всеми спецсимволами, `payload.json`:

```json
{"password": "! \"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"}
```

тут пароль из всех 33 спецсимволов, в тч с пробелом. Хеш:

```
$argon2id$v=19$m=19456,t=2,p=1$5zw5tkTD9xY8+nxzpEKujA$TWXdPypOWUTou1MqE6ndHD09pcHFJAR2MvzxzLniPek
```

Как видишь, тут нет всех этим символов. Защита от SQL-инъекции делается через параметризованные запросы, а хранится пароль в виде вообще хеша. Неважно, что за символы там в пароле — кириллица там, латиница, emoji там, спецсимволы там, вообще неважно. Захешировали, положили, всё.

Идём дальше фантазировать, почему может понадобиться фильтровать символы в пароле. Кто-то в комментах мне пишет — ну чтобы можно было безопасно вставлять пароль на фронтенд-страницу, чтобы защититься от XSS (==покажи XSS==). Но штука в том, что в нормально спроектированной системе пароль никогда не передаётся на фронтенд. Пользователь его однажды ввёл, он отправился на бэкенд и всё, обратно он не возвращается, незачем. Всё остальное — костыли и неправильное проектирование.

Ещё вариант — могут быть проблемы при логировании. Но пароли нельзя логировать, камон! Это секретные данные, их нигде не надо хранить в открытом виде, только в базе в виде хеша, всё. Всё остальное это костыли, за которые надо бить по рукам.

Ещё вариант — пароль при создании пересылается по разным подсистемам и протокол этой коммуникации не позволяет безопасно передать любые символы пароля, какой-нибудь XML. Это тоже всё костыли.  Зашифруйте и перегоняйте шифр, например, да хоть base64, господи, вариантов тьма. Не надо в угоду своей криворукости а) снижать безопасность паролей, а это именно то, что вы делаете, и б) мешать пользователям использовать генераторы и менеджеры паролей.

Нет буквально ни одного, я повторяю, ни одного оправдания этой ерунде, что нельзя использовать какие-то скобочки или вопросительные знаки или кавычки в пароле. Использовать можно любые UNICODE-символы и точка.

Кстати! Уважаемый Роскомнадзор, давайте уже просто сделаем white list паролей и опубликуем его в мессенджере Max. В нём будут только наши, скрепные, подчёркивающие традиционные ценности пароли. Например, 1234. Уважаемый РКН! Мы