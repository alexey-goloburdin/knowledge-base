Здоров, котаны, пару лет уж я наблюдаю, как российские бигтехи постепенно хрюкнулись и стали ограничивать возможные символы в паролях.

![[sber.jpg|600]]

Иии, если раньше я думал, что это какие-то отдельные частные случаи, то сейчас мне уже так не кажется. Это такая феерия идиотизма с одной стороны и такой показатель беспросветного непрофессионализма с другой, что это важно зафиксировать.

О чём речь. Речь о том, что вход в большинство сервисов осуществляется по паролю и чаще всего пароль мы задаём сами. И сервис иногда имеет *требования* к этому паролю. Например, большинство сервисов не пропустит слишком короткий пароль, состоящий из, например, трёх символов, потому что такой пароль можно будет быстро подобрать простым перебором. Пароль из трех символов — это попросту небезопасно, и ограничение минимальной длины пароля объективно разумно.

Сервисы же обычно заставляют нас ставить безопасные пароли — длинные, состоящая из букв, цифр и спецсимволов.  Чем длиннее пароль и чем большее количество символов используется для его составления, тем большее количество вариантов таких паролей существует, и тем сложнее, соответственно, такой пароль подобрать.

Но что же мы видим? Мы видим, что Сбербанк, например, позволяет использовать только разрешённые символы. Например, символ процента и амперсанда использовать в пароле можно, а вот символ кавычки — нельзя. Почему? А вот потому! Вот в Сбербанке изобрели собственную криптографию, в соответствии с которой чтобы пароль был более безопасным, надо... чтобы он был менее безопасным. Вот такая вот криптография! Специальная такая! Инновационная нанотехнологичная криптография!

Аналогично поступает Яндекс для бизнеса — при добавлении сотрудника в Яндекс 360 нельзя вот так взять и использовать произвольный спецсимвол. Альфабанк тоже занимается изобретением собственной криптографии. Туда же Рамблер, cloud.ru. Да что там говорить, люди в себя поверили уже даже в госушных сервисах и такие кренделя выписывают, шо мама не горюй! Личный кабинет индивидуального предпринимателя, пожалуйста, символ решётки использовать можно, а вопросительный знак — нельзя. Ну а чё там вопрошать в пароле? Правильно? Правильно. Незачем.

Даже госуслули не позволяют ввести любой спецсимвол и ограничивают набор спецсимволов, которые можно использовать в пароле.

Причём вот в личном кабинете ИП, скажем, звёздочку использовать в пароле можно, а в госуслугах нельзя. А кавычки в госуслугах можно, а больше нигде — нельзя! А вот скобки в альфа-банке нельзя, а в сбербанке и яндексе можно. Мамкины криптографы пока не договорились, что можно, а что нельзя, что безопасно, а что нет. Тут, вероятно, просто дело такое, что во всех этих организациях изобретается своя православная криптография, и они, эти криптографии, не всегда пересекаются.

Ну, ладненько. Почему это бред?

Ну, во-первых, есть такая штука как комбинаторика. Проходят её в 9м классе школы. То есть, если люди ушли после девятого класса в техникум, а оттуда сразу пошли работать в Сбербанк и Яндекс и Госуслуги, то в целом про комбинаторику они всё равно знать должны.

Так вот в комбинаторике есть такая штука как размещения с повторениями. Она позволяет считать количество вариантов паролей длины `LENGTH`, составленного из символов количеством `SYMBOLS`. Количество вариантов паролей составляет `SYMBOLS ^ LENGTH`.

Вот, например, сколько разных паролей длиной 3 символа может быть составлено из английского алфавита? Как мы знаем, в английском алфавите 26 символов. Поэтому количество версий пароля составляет ( 26^3 ), 17576 паролей. Это не очень много, можно подобрать такой пароль.

А если добавить ещё возможность использовать большие символы алфавита? Будет уже 52 символа в степени 3, 140608. Это в 8 раз больше, чем пароли из только маленьких символов.

Если добавить сюда  цифры, получится 62 в третьей степени, то есть 238328.

Если добавить сюда 33 спецсимвола, которые можно легко набрать на клавиатуре, то получится уже 95 в третьей степени, 857375. Это в 48 раз больше, чем просто маленькие символы английского алфавита.

То есть мы понимаем, что чем больше разных символов мы можем использовать в пароле, тем большее количество паролей одной и той же длины мы можем создать. Тем безопаснее соответственно будет пароль, тем дольше, например, его надо будет подбирать.

Давайте зафиксируем эту простую мысль, доступную девятикласснику. Если в пароле можно использовать все 33 спецсимвола, он будет надёжнее, безопаснее, чем если в пароле можно использовать только 12 спецсимволов, как в большинстве обсуждаемых сервисов. Это комбинаторика, она так работает, есть формула, можно построить график. Это суровый математический аппарат, повторюсь, девятого класса. Надёжность пароля *снижается* при сокращении количества возможных к использованию в пароле символов. Запрет на использовании в пароле восклицательного знака *снижает* его надёжность.

Яндекс, Сбер, Альфабанк, Рамблер, госуслуги и тд — *снижают* безопасность паролей, не позволяя использовать любые символы.

Мы сейчас даже не говорим об использовании произвольных UTF8 символов, например, кириллицы или emoji. Это уж ладно, это уж куда нам.

Это первая мысль. Запрет на использование в пароле какого-то спецсимвола — снижает его безопасность.

Вторая мысль. Давайте порассуждаем, откуда тут могут расти ноги, что в пароле нельзя использовать какой-то символ.

Одни скажут — ну так это жо защита от SQL-инъекции! Ну ты шо, Алексей, ну такие-то уж вещи знать надо, НУ ШО ТЫ ВОТ НАМ РАССКАЗЫВАЕШЬ, ВЫЛЕЗ, КОВЫЧКИ ЕМУ В ПОРОЛЕ ПОДОВАЙ!

И если такое говорит бэкенд-разработчик, то братан, извини, тебя допускать до бэкенд-разработки-то не надо, это нахрен чревато! О чём речь. Речь о том, что вот мы используем PostgreSQL и например Python — это всё актуально и для других языков и СУБД, просто для примера ([github](https://github.com/alexey-goloburdin/innovative-bigtech-cryptography-demo/tree/password_as_plain_text_and_sql_injection)):

```python
import os

import asyncpg
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

load_dotenv()

app = FastAPI()

DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL must be set in .env")

USER_ID = 1


class ChangePasswordRequest(BaseModel):
    password: str


class CheckPasswordRequest(BaseModel):
    password: str


class CheckPasswordResponse(BaseModel):
    valid: bool


async def get_connection():
    return await asyncpg.connect(DATABASE_URL)


@app.post("/password", status_code=204)
async def change_password(payload: ChangePasswordRequest) -> None:
    """
    Change password for the user with id=1.
    """
    conn = await get_connection()

    try:
        result = await conn.execute(
            f"UPDATE users SET password = '{payload.password}' "
            f"WHERE id = {USER_ID}"
        )

        if result == "UPDATE 0":
            raise HTTPException(status_code=404, detail="User not found")

    finally:
        await conn.close()


@app.post("/password/check", response_model=CheckPasswordResponse)
async def check_password(
    payload: CheckPasswordRequest,
) -> CheckPasswordResponse:
    """
    Check given password for the user with id=1.
    """
    conn = await get_connection()
    try:
        row = await conn.fetchrow(
            f"SELECT password FROM users WHERE id = {USER_ID}"
        )
    finally:
        await conn.close()

    if row is None:
        return CheckPasswordResponse(valid=False)

    stored_password = row["password"]
    return CheckPasswordResponse(valid=(stored_password == payload.password))
```

Тут есть 2 сервиса — один устанавливает новый пароль пользователю с заданным идентификатором, а второй сервис проверяет переданный пароль, что он соответствует хранящему в базе данных. Это такая простенькая демка с одним пользователем для демонстрации того, как *в принципе* можно работать с паролем в системе.

```shell
# Меняем пароль пользователю
curl http://localhost:8000/password \
  -H "Content-Type: application/json" \
  -d '{"password": "new_pass"}' \
  -v

# Проверяем, что передан верный пароль пользователя
curl http://localhost:8000/password/check \
  -H "Content-Type: application/json" \
  -d '{"password": "new_pass"}'
```

Код хранится в БД сейчас просто в открытом виде. Смотрим код смены пароля:

```python
        result = await conn.execute(
            f"UPDATE users SET password = '{payload.password}' "
            f"WHERE id = {USER_ID}"
        )
```

Тут есть SQL-инъекция, то есть злоумышленник может передать параметр нового пароля таким, что выполнится произвольный SQL-код. Например, пользователь передаёт вот такой пароль:

```
'; drop table users; --
```

команда в CURL выглядит так:

```shell
curl http://localhost:8000/password \
  -H "Content-Type: application/json" \
  -d '{"password": "'\''; drop table users; --"}' \
  -v
```

И на самом деле мы сейчас удалили таблицу `users`. Смотрим в `psql`.

Почему так произошло? Потому что в БД ушёл такой запрос:

```sql
UPDATE users SET password = ''; drop table users; --' WHERE id = {USER_ID}
```

то есть мы внедрили злонамеренный SQL-запрос и он просто выполнился. Оставшаяся часть запроса после двух символов дефиса не выполнилась, потому что часть после двух дефисов считается комментарием в SQL-запросе и попросту игнорируется.

Как этого избежать? Сейчас уязвимость стала возможной, потому что мы явно разрешаем в пароль вставлять символ кавычки. Давайте просто запретим это делать! Вот просто запретим использовать символ кавычки в пароле и всё:

```python
@app.post("/password", status_code=204)
async def change_password(payload: ChangePasswordRequest) -> None:
    """
    Change password for the user with id=1.
    """
    if "'" in payload.password:
        raise HTTPException(
            status_code=400,
            detail="Password cannot contain a single quote '.",
        )
    conn = await get_connection()

    try:
        result = await conn.execute(
            f"UPDATE users SET password = '{payload.password}' "
            f"WHERE id = {USER_ID}"
        )

        if result == "UPDATE 0":
            raise HTTPException(status_code=404, detail="User not found")

    finally:
        await conn.close()

@app.post("/password/check", response_model=CheckPasswordResponse)
async def check_password(
    payload: CheckPasswordRequest,
) -> CheckPasswordResponse:
    """
    Check given password for the user with id=1.
    """
    if "'" in str(USER_ID):
        raise HTTPException(
            status_code=500,
            detail="Incorrect user_id.",
        )
    ...
```

[github](https://github.com/alexey-goloburdin/innovative-bigtech-cryptography-demo/tree/password_as_plain_text_and_quote_filter)

Теперь попытка провести такую атаку на SQL-инъекцию не проходит. Ура-ура! Мы всё побороли! Или не всё? А точно всё побороли?

А вот ещё вопрос — а как насчёт отправки, например, произвольных сообщений, в которых может быть любой символ? Ведь там кавычку могут ведь отправить. Вот вы комментарии под видео пишете — там ведь кавычку можно отправить, и любой вообще символ можно отправить? Но при этом уязвимости нет. Как тогда это сделано?

А сделано это просто по уму. По уму не надо фильтровать ввод, который приходит от пользователя, на предмет наличия в нём кавычек или любых других потенциально вредных символов. Надо просто пользоваться плейсхолдерами.



радужные таблицы


Я думаю, РКН для порядку надо запретить использовать в паролях всё, что не наши, православные, подчёркивающие традиционные ценности цифры 1234!