Как хранит данные Postgres и как использовать это знание для увеличения производительности запросов?

## Как работает Postgres

Где лежат все файлы баз данных? Они лежат в хранилище, которое называют кластером баз данных. Документация гласит, что 

> Кластер баз данных представляет собой набор баз, управляемых одним экземпляром работающего сервера.

То есть в постгресе кластер это не набор серверов с репликацией и так далее. Когда вы на один компьютер устанавливаете Postgres, то в процессе установки автоматически или вручную происходит инициализация кластера, то есть инициализация этой директории, в которой будут храниться данные всех баз данных.

Ну так вот, место на диске, где хранятся эти файлы, можно посмотреть в параметре 

```sql
SHOW data_directory;
-- /var/lib/postgresql/16/main
```

На выполнение этого запроса необходимы права, от обычного пользователя он не сработает, поэтому можно запустить от пользователя базы данных `postgres`.

В этой директории лежат данные кластера, то есть всех баз данных, входящих в кластер:

```bash
sudo ls -l /var/lib/postgresql/16/main
```

Как посмотреть, где лежат данные конкретной БД?

Данные БД могут лежать в разных табличных пространствах, то есть разных директориях, а как мы помним в linux мы можем примонтировать в директорию целый диск. То есть одни таблицы могут быть на медленных больших дисках, а другие таблицы могут быть на быстрых дисках. При необходимости.

Или разные БД могут быть на разных табличных пространствах.

Посмотрим, какое табличное пространство использует БД:

```sql
SELECT pg_database.datname, pg_tablespace_location(pg_database.dattablespace) AS tablespace_location
FROM pg_database
WHERE datname = 'birds';
```

Видим пустой `tablespace_location`, значит, используется стандартное табличное пространство. Его расположение это директория `base` в `data_directory`, то есть `/var/lib/postgresql/16/main/base`. Отлично!

А где там данные нашей БД? Для этого можно достать идентификатор этой БД:

```sql
SELECT oid FROM pg_database WHERE datname = 'birds';
-- 32774
```

Значит, данные БД лежат в `data_directory/base/32774`.

В этой директории мы видим тоже файлы с именами из чисел — это идентификаторы таблиц.

Как посмотреть, где лежат данные таблицы?

```sql
select pg_relation_filepath('wide_employee');
--  base/32774/74776
```

Посмотрим:

```bash
sudo ls -l /var/lib/postgresql/16/main/base/32774/74776
```

При этом файлов может быть больше одного:

```bash
sudo ls -l /var/lib/postgresql/16/main/base/32774 | grep 74776

-rw------- 1 postgres postgres 1073741824 Sep 30 03:33 74776
-rw------- 1 postgres postgres  958382080 Sep 30 03:33 74776.1
```

Здесь мы видим 2 файла, два сегмента — сначала данные таблицы писались в первый файл, потом когда его размер превысил заданный порог в гигабайт, то создался файл второго сегмента данные стали писаться туда. Размер в гигабайт можно изменить при сборке постгреса при необходимости через свой параметр параметр `./configure --with-segsize`. Надо уметь собирать софт из исходников, чтобы получать такие возможности. Из пакетного менеджера вашей операционной системы вы поставите только то, что там для вас уже собрали с дефолтными параметрами.

Там могут быть еще файлы fsm — карта свободного пространства, и файлы vm — карта видимости.

```sql
update wide_employee set email='tmp@example.com' where employee_id =1;
```

Посмотрим файлы:

```bash
sudo ls -l /var/lib/postgresql/16/main/base/32774 | grep 74776

-rw------- 1 postgres postgres 1073741824 Sep 30 18:21 74776
-rw------- 1 postgres postgres  958382080 Sep 30 18:21 74776.1
-rw------- 1 postgres postgres     516096 Sep 30 18:21 74776_fsm
-rw------- 1 postgres postgres      65536 Sep 30 18:21 74776_vm
```

Отлично! Об этих fsm-файлах и vm-файлах можете почитать в документации или замечательной книге «PostgreSQL 16 изнутри», нам тут это пока неважно.

Ну так вот реально данные таблицы хранятся в этих великолепных файлах. Давайте посмотрим бинарное содержание файла, который хранит данные таблицы:

```bash
sudo xxd /var/lib/postgresql/16/main/base/32774/74776 | head -50 | less
```

Здесь мы видим те данные, которые мы записали в эту таблицу. Кайф!

Как организованы эти файлы? Они организованы в блоки по 8 Кбайт, которые называют также страницами. Этот размер в 8 Кбайт можно изменить при сборке постгреса, но как правило он именно 8 Кбайт. И это минимальное количество данных, которое постгрес может прочесть с диска.

Если нам надо достать одно маленькое число, хранимое в таблице — Postgres прочитает как минимум 8 Кбайт. В этих 8 Кбайт будет несколько строк таблицы, и в одной из этих строк будет нужное нам число.

Когда страница считалась из файла, она помещается в оперативную память в буферный кеш может храниться какое-то время в этом кеше.

Соответственно когда постгрес ищет данные, он может прочесть их из буферного кеша, то есть из оперативной памяти, то есть это очень быстро, или он может прочесть эти данные с диска, что будет медленнее.

Что тут надо понять, что тут интересно?

Интересно тут, во-первых, то, что все файлы побиты на 8 Кбайт и система работает с такими блоками. Во-вторых, мы понимаем, что хорошо, если в каждую страницу поместится больше строк таблицы, чтобы система могла считать меньшее количество страниц с диска. Потому что работа с диском медленная. Плюс в буферном кеше в оперативной памяти кешируются тоже страницы и если на странице будет много строк, то получается, что мы бОльшую часть таблицы можем закешировать в оперативной памяти, что тоже хорошо.

Иными словами — как правило не надо делать слишком широкие таблицы, состоящие из большого количества колонок. А это как раз приводит нас к использованию связи один к одному.

Вот мы храним данные сотрудников. Какие данные часто будут получаться? Какие данные по каждому сотруднику — основные? Вероятно это его уникальный идентификатор и имя-фамилия. А остальные данные нужны в своих сценариях отдельных. Бухгалтерии нужны поля по зарплате, кадровикам по грейду и дате трудоустройства и тд.

Когда мы храним все эти данные вместе в одной широкой таблице, то мы вынуждены считывать с диска все эти данные, даже если нам нужны только имя и фамилия.

То есть когда мы пишем запрос:

```sql
select first_name, last_name from wide_employee;
```

система считывает с диска в том числе адреса сотрудников, их грейды, зарплаты и все прочие данные. Это неэффективно.

А когда в основной таблице по сотрудникам только необходимые поля, то считываются только они


## Дальше


```sql
-- from postgres user
create extension pg_buffercache;

-- see used and unused buffers count
select * from pg_buffercache_summary();

show work_mem;
set work_mem='128MB';

EXPLAIN (analyze, buffers)
SELECT employee_id, first_name, last_name FROM wide_employee where department_id='HR' order by employment_date limit 20;
-- Buffers: shared hit=114 read=248062
-- Execution Time: 1370.851 ms
-- памяти work_mem хватает

-- sudo systemctl restart postgresql
EXPLAIN (analyze, buffers)

SELECT e.employee_id, e.first_name, e.last_name
FROM employee e
JOIN employee_hierarchy eh ON e.employee_id = eh.employee_id
WHERE department_id='HR' order by employment_date limit 20;
-- уходим в файловый кеш, ребутаем и поднимаем work_mem до 128MB
-- Buffers: shared hit=138 read=85877
-- Execution Time: 1453.068 ms



```

Разнести по разным СУБД два сценария
Сравнить размер СУБД (с учетом индексов PK)
Сказать про сценарий является и владеет (или как-то так)

[[Сценарий]]